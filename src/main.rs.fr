use std::fs::{File, OpenOptions};
use std::io::{Write, BufWriter};
use std::net::SocketAddr;
use std::path::PathBuf;
use std::sync::Arc;

use anyhow::{Result, Context};
use chrono::Local;
use lazy_static::lazy_static;
use regex::Regex;
use structopt::StructOpt;
use tokio::net::UdpSocket;
use tokio::sync::Mutex;
use tokio::time;

#[derive(Debug, StructOpt, Clone)]
#[structopt(
    name = "sip-honeypot",
    about = "Un honeypot SIP pour détecter et analyser les attaques SIP",
    author = "Philippe TEMESI <https://www.tems.be>",
    version = "0.1.0"
)]
struct Opt {
    /// Démarrer en mode démon
    #[structopt(short = "d", long = "daemon")]
    daemon: bool,
    
    /// Port d'écoute (5060 par défaut)
    #[structopt(short = "p", long = "port", default_value = "5060")]
    port: u16,
    
    /// Fichier de log
    #[structopt(short = "l", long = "log", parse(from_os_str))]
    log_file: Option<PathBuf>,
    
    /// Adresse d'écoute
    #[structopt(short = "a", long = "address", default_value = "0.0.0.0")]
    address: String,
    
    /// Afficher l'aide
    #[structopt(short = "h", long = "help")]
    help: bool,
    
    /// Afficher la version
    #[structopt(short = "V", long = "version")]
    version: bool,
}

#[derive(Clone)]
struct SipHoneypot {
    socket: Arc<UdpSocket>,
    log_writer: Option<Arc<Mutex<BufWriter<File>>>>,
}

impl SipHoneypot {
    async fn new(addr: &str, port: u16, log_file: Option<PathBuf>) -> Result<Self> {
        let bind_addr = format!("{}:{}", addr, port);
        let socket = UdpSocket::bind(&bind_addr).await
            .with_context(|| format!("Impossible de se lier à {}", bind_addr))?;
        
        println!("[INFO] Serveur SIP honeypot démarré sur {}", bind_addr);
        
        let log_writer = if let Some(path) = &log_file {
            let file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(path)
                .with_context(|| format!("Impossible d'ouvrir le fichier de log: {:?}", path))?;
            println!("[INFO] Journalisation activée dans: {:?}", path);
            Some(Arc::new(Mutex::new(BufWriter::new(file))))
        } else {
            println!("[INFO] Journalisation désactivée (utilisez -l pour activer)");
            None
        };
        
        Ok(Self {
            socket: Arc::new(socket),
            log_writer,
        })
    }
    
    async fn log(&self, client_addr: &SocketAddr, message: &str) {
        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S%.3f");
        let log_line = format!("{} [{}] {}\n", timestamp, client_addr, message);
        
        // Toujours afficher sur stdout
        print!("{}", log_line);
        
        // Écrire dans le fichier si spécifié
        if let Some(writer) = &self.log_writer {
            let mut writer = writer.lock().await;
            if let Err(e) = writer.write_all(log_line.as_bytes()) {
                eprintln!("[ERREUR] Écriture dans le log: {}", e);
            }
            if let Err(e) = writer.flush() {
                eprintln!("[ERREUR] Flush du log: {}", e);
            }
        }
    }
    
    async fn handle_packet(&self, buf: &[u8], client_addr: SocketAddr) {
        let packet_str = String::from_utf8_lossy(buf);
        
        // Vérifier si c'est du SIP
        if Self::is_sip_packet(&packet_str) {
            self.log(&client_addr, &format!("Packet SIP reçu ({} octets)", buf.len())).await;
            
            // Analyser la méthode SIP
            if let Some(method) = Self::parse_sip_method(&packet_str) {
                self.log(&client_addr, &format!("Méthode SIP détectée: {}", method)).await;
                
                // Répondre selon la méthode
                let response = match method.as_str() {
                    "REGISTER" => self.handle_register(&packet_str, &client_addr).await,
                    "INVITE" => self.handle_invite(&packet_str, &client_addr).await,
                    "OPTIONS" => self.handle_options(&packet_str, &client_addr).await,
                    "BYE" => self.handle_bye(&packet_str, &client_addr).await,
                    "CANCEL" => self.handle_cancel(&packet_str, &client_addr).await,
                    "ACK" => self.handle_ack(&packet_str, &client_addr).await,
                    "RESPONSE" => self.handle_response(&packet_str, &client_addr).await,
                    _ => self.handle_unknown(&packet_str, &client_addr).await,
                };
                
                if !response.is_empty() {
                    if let Err(e) = self.socket.send_to(response.as_bytes(), client_addr).await {
                        self.log(&client_addr, &format!("Erreur d'envoi de réponse: {}", e)).await;
                    } else {
                        self.log(&client_addr, &format!("Réponse envoyée ({} octets)", response.len())).await;
                    }
                }
            } else {
                self.log(&client_addr, "Packet SIP non reconnu").await;
            }
        } else {
            self.log(&client_addr, &format!("Packet non-SIP reçu ({} octets) - Ignoré", buf.len())).await;
        }
    }
    
    fn is_sip_packet(packet: &str) -> bool {
        lazy_static! {
            static ref SIP_REGEX: Regex = Regex::new(r"^(REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|SUBSCRIBE|NOTIFY|PUBLISH|MESSAGE|REFER|INFO|PRACK|UPDATE|SIP/2\.0)").unwrap();
        }
        SIP_REGEX.is_match(packet.trim())
    }
    
    fn parse_sip_method(packet: &str) -> Option<String> {
        lazy_static! {
            static ref METHOD_REGEX: Regex = Regex::new(r"^(REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|SUBSCRIBE|NOTIFY|PUBLISH|MESSAGE|REFER|INFO|PRACK|UPDATE)").unwrap();
        }
        
        if let Some(caps) = METHOD_REGEX.captures(packet.trim()) {
            caps.get(1).map(|m| m.as_str().to_string())
        } else if packet.contains("SIP/2.0") {
            Some("RESPONSE".to_string())
        } else {
            None
        }
    }
    
    async fn handle_register(&self, packet: &str, client_addr: &SocketAddr) -> String {
        self.log(client_addr, "Traitement d'une demande REGISTER").await;
        
        // Extraire l'utilisateur depuis le packet
        let user = Self::extract_user_from_packet(packet).unwrap_or_else(|| "unknown".to_string());
        
        // Simuler un enregistrement réussi - pas d'infos sur le honeypot
        format!("SIP/2.0 200 OK\r\n\
                Via: {}\r\n\
                From: <sip:{}@example.com>\r\n\
                To: <sip:{}@example.com>\r\n\
                Call-ID: {}\r\n\
                CSeq: 1 REGISTER\r\n\
                Contact: <sip:{}@{}:5060>\r\n\
                Expires: 3600\r\n\
                Content-Length: 0\r\n\r\n",
                Self::extract_via_header(packet).unwrap_or("SIP/2.0/UDP example.com:5060".to_string()),
                user, user,
                Self::extract_call_id(packet).unwrap_or_else(|| "12345".to_string()),
                user, client_addr.ip())
    }
    
    async fn handle_invite(&self, packet: &str, client_addr: &SocketAddr) -> String {
        self.log(client_addr, "Traitement d'une demande INVITE (simulation d'appel)").await;
        
        // Extraire les informations nécessaires avant de les passer au thread
        let to_number = Self::extract_to_number(packet).unwrap_or_else(|| "100".to_string());
        let from_header = Self::extract_from_header(packet).unwrap_or_else(|| "<sip:attacker@unknown>".to_string());
        let via_header = Self::extract_via_header(packet).unwrap_or_else(|| "SIP/2.0/UDP example.com:5060".to_string());
        let call_id = Self::extract_call_id(packet).unwrap_or_else(|| "12345".to_string());
        let cseq = Self::extract_cseq_number(packet).unwrap_or(1);
        
        // Cloner les données nécessaires pour le thread
        let honeypot_clone = self.clone();
        let client_addr_clone = client_addr.clone();
        let to_number_clone = to_number.clone();
        let from_header_clone = from_header.clone();
        let via_header_clone = via_header.clone();
        let call_id_clone = call_id.clone();
        
        // Simuler une sonnerie immédiate
        let ring_response = format!("SIP/2.0 180 Ringing\r\n\
                Via: {}\r\n\
                From: {}\r\n\
                To: <sip:{}@example.com>\r\n\
                Call-ID: {}\r\n\
                CSeq: {} INVITE\r\n\
                Content-Length: 0\r\n\r\n",
                via_header,
                from_header,
                to_number,
                call_id,
                cseq);
        
        // Démarrer un thread pour simuler le décrochage après 2 secondes
        tokio::spawn(async move {
            time::sleep(time::Duration::from_secs(2)).await;
            
            // Envoyer un 200 OK pour simuler le décrochage
            let ok_response = format!("SIP/2.0 200 OK\r\n\
                    Via: {}\r\n\
                    From: {}\r\n\
                    To: <sip:{}@example.com>\r\n\
                    Call-ID: {}\r\n\
                    CSeq: {} INVITE\r\n\
                    Contact: <sip:{}@{}:5060>\r\n\
                    Content-Type: application/sdp\r\n\
                    Content-Length: 142\r\n\r\n\
                    v=0\r\n\
                    o=user 123456 123456 IN IP4 {}\r\n\
                    s=Appel\r\n\
                    c=IN IP4 {}\r\n\
                    t=0 0\r\n\
                    m=audio 1234 RTP/AVP 0 8 101\r\n\
                    a=rtpmap:0 PCMU/8000\r\n\
                    a=rtpmap:8 PCMA/8000\r\n\
                    a=rtpmap:101 telephone-event/8000\r\n",
                    via_header_clone,
                    from_header_clone,
                    to_number_clone,
                    call_id_clone,
                    cseq,
                    to_number_clone, client_addr_clone.ip(),
                    client_addr_clone.ip(),
                    client_addr_clone.ip());
            
            if let Err(e) = honeypot_clone.socket.send_to(ok_response.as_bytes(), client_addr_clone).await {
                honeypot_clone.log(&client_addr_clone, &format!("Erreur d'envoi 200 OK: {}", e)).await;
            } else {
                honeypot_clone.log(&client_addr_clone, "200 OK envoyé (simulation décrochage)").await;
            }
        });
        
        ring_response
    }
    
    async fn handle_options(&self, packet: &str, client_addr: &SocketAddr) -> String {
        self.log(client_addr, "Traitement d'une demande OPTIONS").await;
        
        format!("SIP/2.0 200 OK\r\n\
                Via: {}\r\n\
                From: {}\r\n\
                To: {}\r\n\
                Call-ID: {}\r\n\
                CSeq: {} OPTIONS\r\n\
                Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REGISTER\r\n\
                Accept: application/sdp\r\n\
                Accept-Encoding: gzip\r\n\
                Accept-Language: en, fr\r\n\
                Content-Length: 0\r\n\r\n",
                Self::extract_via_header(packet).unwrap_or("SIP/2.0/UDP example.com:5060".to_string()),
                Self::extract_from_header(packet).unwrap_or("<sip:attacker@unknown>".to_string()),
                Self::extract_to_header(packet).unwrap_or("<sip:attacker@unknown>".to_string()),
                Self::extract_call_id(packet).unwrap_or_else(|| "12345".to_string()),
                Self::extract_cseq_number(packet).unwrap_or(1))
    }
    
    async fn handle_bye(&self, packet: &str, client_addr: &SocketAddr) -> String {
        self.log(client_addr, "Traitement d'une demande BYE (fin d'appel)").await;
        
        format!("SIP/2.0 200 OK\r\n\
                Via: {}\r\n\
                From: {}\r\n\
                To: {}\r\n\
                Call-ID: {}\r\n\
                CSeq: {} BYE\r\n\
                Content-Length: 0\r\n\r\n",
                Self::extract_via_header(packet).unwrap_or("SIP/2.0/UDP example.com:5060".to_string()),
                Self::extract_from_header(packet).unwrap_or("<sip:attacker@unknown>".to_string()),
                Self::extract_to_header(packet).unwrap_or("<sip:attacker@unknown>".to_string()),
                Self::extract_call_id(packet).unwrap_or_else(|| "12345".to_string()),
                Self::extract_cseq_number(packet).unwrap_or(1))
    }
    
    async fn handle_cancel(&self, _packet: &str, client_addr: &SocketAddr) -> String {
        self.log(client_addr, "Traitement d'une demande CANCEL").await;
        
        "SIP/2.0 200 OK\r\n\
         Content-Length: 0\r\n\r\n".to_string()
    }
    
    async fn handle_ack(&self, packet: &str, client_addr: &SocketAddr) -> String {
        self.log(client_addr, "Traitement d'une demande ACK").await;
        
        let call_id = Self::extract_call_id(packet).unwrap_or_else(|| "inconnu".to_string());
        self.log(client_addr, &format!("ACK pour Call-ID: {}", call_id)).await;
        
        "".to_string()
    }
    
    async fn handle_response(&self, packet: &str, client_addr: &SocketAddr) -> String {
        if let Some(status_code) = Self::extract_status_code(packet) {
            self.log(client_addr, &format!("Réponse SIP reçue - Code: {}", status_code)).await;
        } else {
            self.log(client_addr, "Réponse SIP reçue").await;
        }
        
        "".to_string()
    }
    
    async fn handle_unknown(&self, packet: &str, client_addr: &SocketAddr) -> String {
        let first_line = packet.lines().next().unwrap_or("");
        self.log(client_addr, &format!("Méthode SIP inconnue reçue: {}", first_line)).await;
        
        "SIP/2.0 501 Not Implemented\r\n\
         Content-Length: 0\r\n\r\n".to_string()
    }
    
    // Méthodes d'extraction d'informations SIP
    fn extract_user_from_packet(packet: &str) -> Option<String> {
        let re = Regex::new(r"(?i)From:\s*[^<]*<sip:([^@>]+)").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .map(|m| m.as_str().to_string())
    }
    
    fn extract_via_header(packet: &str) -> Option<String> {
        let re = Regex::new(r"(?i)Via:\s*(.*?)\r\n").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .map(|m| m.as_str().to_string())
    }
    
    fn extract_call_id(packet: &str) -> Option<String> {
        let re = Regex::new(r"(?i)Call-ID:\s*(.*?)\r\n").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .map(|m| m.as_str().to_string())
    }
    
    fn extract_from_header(packet: &str) -> Option<String> {
        let re = Regex::new(r"(?i)From:\s*(.*?)\r\n").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .map(|m| m.as_str().to_string())
    }
    
    fn extract_to_header(packet: &str) -> Option<String> {
        let re = Regex::new(r"(?i)To:\s*(.*?)\r\n").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .map(|m| m.as_str().to_string())
    }
    
    fn extract_cseq_number(packet: &str) -> Option<u32> {
        let re = Regex::new(r"(?i)CSeq:\s*(\d+)").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .and_then(|m| m.as_str().parse().ok())
    }
    
    fn extract_to_number(packet: &str) -> Option<String> {
        let re = Regex::new(r"(?i)To:\s*[^<]*<sip:([^@>]+)").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .map(|m| m.as_str().to_string())
    }
    
    fn extract_status_code(packet: &str) -> Option<u16> {
        let re = Regex::new(r"SIP/2\.0\s+(\d{3})").unwrap();
        re.captures(packet)
            .and_then(|caps| caps.get(1))
            .and_then(|m| m.as_str().parse().ok())
    }
    
    async fn run(self: Arc<Self>) -> Result<()> {
        let mut buf = [0u8; 65536]; // Taille maximale pour UDP
        
        println!("[INFO] En attente de paquets UDP...");
        
        loop {
            match time::timeout(time::Duration::from_secs(5), self.socket.recv_from(&mut buf)).await {
                Ok(Ok((len, client_addr))) => {
                    let packet = buf[..len].to_vec();
                    let honeypot = self.clone();
                    
                    tokio::spawn(async move {
                        honeypot.handle_packet(&packet, client_addr).await;
                    });
                }
                Ok(Err(e)) => {
                    eprintln!("[ERREUR] Réception: {}", e);
                }
                Err(_) => {
                    // Timeout - pas de données reçues en 5 secondes
                    // C'est normal pour un serveur qui attend
                }
            }
        }
    }
}

#[cfg(unix)]
fn daemonize() -> Result<()> {
    use daemonize::Daemonize;
    
    println!("[INFO] Démarrage en mode démon...");
    
    let daemonize = Daemonize::new()
        .pid_file("/tmp/sip-honeypot.pid")
        .chown_pid_file(true)
        .working_directory("/tmp")
        .user("nobody")
        .group("nogroup")
        .umask(0o027);
    
    match daemonize.start() {
        Ok(_) => {
            println!("[INFO] Démon SIP honeypot démarré avec succès");
            Ok(())
        }
        Err(e) => {
            eprintln!("[ERREUR] Démarrage en mode démon: {}", e);
            Err(anyhow::anyhow!("Échec du démarrage en mode démon"))
        }
    }
}

#[cfg(windows)]
fn daemonize() -> Result<()> {
    use std::process;
    
    println!("[INFO] Le mode démon n'est pas pleinement supporté sur Windows");
    println!("[INFO] Le programme continue en arrière-plan...");
    
    Ok(())
}

#[cfg(not(any(unix, windows)))]
fn daemonize() -> Result<()> {
    println!("[INFO] Le mode démon n'est pas supporté sur cette plateforme");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // Parse les arguments de ligne de commande
    let opt = Opt::from_args();
    
    // Afficher la version si demandé
    if opt.version {
        println!("SIP Honeypot v{}", env!("CARGO_PKG_VERSION"));
        println!("2026, {}", env!("CARGO_PKG_AUTHORS"));
    //    println!("}", env!("CARGO_PKG_REPOSITORY"));
        return Ok(());
    }
    
    // Afficher l'aide si demandé
    if opt.help {
        Opt::clap().print_help()?;
        println!();
        return Ok(());
    }
    
    // Afficher les informations de démarrage
    println!("==========================================");
    println!("SIP Honeypot v{}", env!("CARGO_PKG_VERSION"));
    println!("Auteur: {}", env!("CARGO_PKG_AUTHORS"));
    println!("Site web: {}", env!("CARGO_PKG_REPOSITORY"));
    println!("==========================================");
    
    // Sauvegarder le chemin du fichier de log avant de déplacer opt
    let log_file = opt.log_file.clone();
    
    // Démarrer en mode démon si demandé
    if opt.daemon {
        daemonize()?;
    }
    
    // Créer et démarrer le honeypot
    let honeypot = Arc::new(SipHoneypot::new(&opt.address, opt.port, log_file).await?);
    
    println!("[INFO] Honeypot SIP démarré");
    println!("[INFO] Adresse: {}:{}", opt.address, opt.port);
    println!("[INFO] Mode démon: {}", opt.daemon);
    println!("[INFO] En attente de connexions...");
    println!("[INFO] Appuyez sur Ctrl+C pour arrêter");
    
    // Démarrer le serveur
    honeypot.run().await?;
    
    Ok(())
}
